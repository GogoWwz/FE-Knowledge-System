##  closure

### 开始

闭包这玩意儿，反正在我这儿属于，看完不过如此，没过多久模模糊糊

后来想了想，是因为自己从来没试过去玩闭包，也就是单方面的去学习书本、博客输送给我的知识

也就造成理解不深的问题

所以，今天打算换个思路，自己给自己出题，自己玩，然后说出自己的理解

首先，先看个例子：

```javascript
// 每隔一秒打印i
for(var i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i)
  }, i * 1000)
}
// 5
// 5
// 5
// 5
// 5
```

本来想每隔一秒当时的i，因为定时器是宏任务，所以等for循环执行完了，才执行定时器，所以打印了五个5

我想了想，为了实现我们的目的，我们可以有以下方法

```javascript
// 利用bind保留当前i
for(var i = 0; i < 5; i++) {
  setTimeout((function(j) {
    console.log(j)
  }).bind(null, i), i * 1000)
}

// 利用立即执行函数中的作用域保留i
for(var i = 0; i < 5; i++) {
  (function(j) {
    setTimeout(() => {
      console.log(j)
    }, j * 1000)
  })(i)
}

// 利用let自带的块及级用域
for(let i = 0; i < 5; i++) {
  setTimeout(() => {
    console.log(i)
  }, i * 1000)
}
```

说白了，我们的思路很简单，就是想方设法保留每次执行回调时候的i值

**只要函数访问了他所在作用域的变量，就产生了闭包**

为什么要被函数包裹？

因为js中就没有块级作用域这个玩意儿，只有函数作用域

为什么要返回函数？

返回只不过是为了调用而已，不返回直接挂到window上没区别啊。是不是闭包是一回事，用不用闭包是另一回事

为什么不说导致变量无法释放？

因为无法释放是闭包的效果，并不是产生闭包的原因

如果还是很纠结，那就来个最简单的例子：

```javascript
var a = 1

function fn() {
	console.log(++a)
}
```

上面这代码形成闭包了吗？

fn能访问到他所在作用域windows的变量————这就是已经产生了闭包

你肯定难以置信，那我们加点东西：

```javascript
var a = 1
function fn() {
	console.log(++a)
}

fn() // 2
fn() // 3
```

明白了没，从我们正常的思维来说，这个`console.log(a)`是不是应该是报错？

你会说，这不是词法作用域的作用吗？

但换个角度来说，访问不在自身作用域内的变量，这难道不是一个副作用么？

只不过因为此时的环境是全局，所以你会觉得这个a还能被访问是理所当然的

所以我们加上立即执行函数，使其在一个局部作用域中：

```javascript
(function() {
 	var a = 1
  	function fn() {
        console.log(++a)
 	}
	window.fn = fn
})()

fn() // 2
fn() // 3
```

这个时候fn也能在全局作用域访问操作局部作用域中的a变量

这两个例子有什么区别么？

无非就是我将第二个例子用局部作用域包裹了起来，但这并不影响　ａ　和　ｆｎ　已经形成了闭包

所以，闭包的产生很简单：

就是当函数内部访问了其所在环境的变量，就OK了

所以才说我们平时开发中闭包无处不在

### 话术

上面是分析之后的结论，怎么用我们自己的一套理解把他说出来呢？

A：你了解闭包吗？

B：我的理解就是当函数内部访问了其所在所用域的变量，就形成了闭包

A：能详细说说吗？

B：当JS引擎在词法分析的时候，调用栈会生成一个词法环境和变量环境，